\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\lstset{inputpath=../listings}
\usepackage{color}
\usepackage{here} 
\usepackage{graphicx}
\graphicspath{{pics/}}

\usepackage{caption}
\renewcommand{\lstlistingname}{Листинг}

\usepackage{listings}
\lstdefinestyle{base_listing}{ %
extendedchars=\true,
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
keepspaces = true
}

\lstdefinestyle{crs_bash}{
  style    = {base_listing},
  language = {bash}
}

\lstdefinestyle{crs_cpp}{
  style    = {base_listing},
  language = {C++}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm]
\large Отчет по лабораторной работе №6\\[0.1cm]
\large Средства межпроцессного взаимодействия в ОС Windows\\[5cm]
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство


\section{Цель работы}
	Изучить средства межпроцессного взаимодействия в ОС Windows.
	
\section{Программа работы}
\begin{enumerate}
\item Неименованные каналы.\\
1.1. Создать клиент-серверное приложение, позволяющее набираемые символы в терминальном окне командной строки (сервер) отображать их в окно процесса-потомка (клиент).\\
1.2.Создать эхо-сервер, взаимодействующий с клиентом посредством pipe.
\item Именованные каналы.\\
2.1.Программа, обеспечивающая взаимодействие процессов посредством именованных каналов.Реализовать между одним клиентом и сервером обмен данными, вводимыми с консоли на стороне клиента и возвращаемыми сервером обратно до получения команды exit.\\
2.2. Программа, обеспечивающая взаимодействие процессов посредством именованных каналов – аналогичная программа с эхо-сервером, но с множеством клиентов и принудительной блокировкой обмена до завершения каждой операции. Реализовать между сервером и множеством клиентов обмен данными, вводимыми с консоли на стороне клиента и возвращаемыми сервером обратно до получения команды exit.\\
2.3. Модифицируем приложение из предыдущего примера (2.2) для сетевого обмена информацией.
\item Сокеты.\\
3.1. Программа локального обмена сокетами с использованием потокового протокола с установлением соединения (TCP в стеке TCP/IP).\\
3.2. Модифицировать программу для локального обмена с множеством клиентов и с доступом к общему ресурсу.\\
3.3. Сетевая передача данных с помощью сокетов.
\item  Провести эксперимент с множеством клиентов при сетевом обмене, представить результаты для виртуальной и реальной сетей;
\item  Проанализировать пример применения сокетов (сетевой обмен «мгновенными» сообщениями). Представить архитектуру приложения, алгоритмы сервера и клиента, схему и диаграмму их взаимодействия. Составить спецификацию функций (имя, назначение, параметры, файлы). Дополнить приложение, предоставив возможность обмениваться информацией клиентам в Linux и Windows. Исходный код в приложении. Настроить функционирование в лабораторной сети. Описать необходимые настройки.
\item  Привести примеры использования портов завершения. Привести пример приложения с большим количеством клиентов до 1000 (когда порты завершения оправданы), общее количество потоков не более 10.
\item  Оформить приложение с сокетами в виде службы.
\item  Реализовать обмен на основе UDP
\item  Сигналы в Windows\\
9.1. В качестве примера рассмотрим код из msdn. В нем происходит перехват сигналов CTRL+C, CTRL+BREAK. При этом обработчик смотрит, какой сигнал ему передан, и выводит его название. В качестве звуковой индикации работы приложение вызывает функцию Beep.\\
9.2. Предложить собственную реализацию обработчика сигнала.
\item Взаимодействие двух процессов через совместно используемую именованную память, при котором первый процесс записывает данные, а второй считывает их. Создать программу, в которой первый процесс генерирует случайное число и записывает его в буфер, доступный второму процессу, откуда он его и считывает с последующим выводом.
\item  Предложить собственную реализацию приложения, иллюстрирующую обмен информацией почтовыми слотами. Продемонстрировать возможность локального и удаленного доступа. Выполнить широковещательную передачу данных.
\end{enumerate}

\section{Ход работы}
Основная рабочая станция:\begin{lstlisting}[frame=rltb,numbers=none]
OS Name:                   Microsoft Windows 10 Pro
OS Version:                10.0.10586 N/A Build 10586
...
Wireless LAN adapter Wi-Fi 2:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::58c4:2b5b:1f7:4fa7%6
   IPv4 Address. . . . . . . . . . . : 192.168.1.27
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
	\end{lstlisting}
	
Дополнительная рабочая станция:\begin{lstlisting}[frame=rltb,numbers=none]
OS Name:                   Microsoft Windows 10 Pro
OS Version:                10.0.10586 N/A Build 10586
...
Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::a593:35fa:9f2:9f2c%4
   IPv4 Address. . . . . . . . . . . : 192.168.1.36
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
	\end{lstlisting}
Стоит заметить, что дополнительная рабочая станция является виртуальной машиной с прямым доступом в локальную сеть. Использовался компилятор MinGW 4.9.2 x32.

\subsection{Неименованные каналы (Pipe)}
	Посредством pipe-канала можно передавать данные только между двумя процессами. В основе взаимодействия лежит так называемая файловая модель функционирования. Один из процессов создает канал, другой открывает его. После этого оба процесса могут передавать данные через канал в одну или обе стороны, используя для этого функции, предназначенные для работы с файлами, такие как \textbf{ReadFile} и \textbf{WriteFile}.
	
	Анонимные каналы (anonymous channels) Windows обеспечивают однонаправленное (полудуплексное) посимвольное межпроцессное взаимодействие. Каждый канал имеет два дескриптора: дескриптор чтения (read handle) и дескриптор записи (write handle).
	
	После создания канала необходимо передать клиентскому процессу его дескрипторы (или один из них), что обычно делается с помощью механизма наследования. Для наследования описателя нужно, чтобы процесс-потомок создавался функцией CreateProcess с флагом наследования TRUE.
	
	\textbf{Задание} Создать клиент-серверное приложение, позволяющее набираемые символы в терминальном окне командной строки (сервер) отображать их в окно процесса-потомка (клиент).
В программе-сервере master создается неименованный канал для связи с процессом-потомком, порождается сам процесс-потомок (программа-клиент) slave. На стороне сервера производится запись из консоли в канал. В slave открывается неименованный канал и осуществляется считывание из него в новое окно. Запись/чтение канала производится с помощью стандартных потоков \texttt{std\_in} и \texttt{std\_out}.

	Исходный код программы pipe\_master:
	\lstinputlisting[style=crs_cpp]{pipe_master.cpp}
	
	
	Исходный код программы pipe\_slave:
	\lstinputlisting[style=crs_cpp]{pipe_slave.cpp}
	
	При запуске "сервера" в командной строке выводится текст "Pipe Created!", затем сервером порождается процесс "slave" в новом окне, после чего любые символы, которые пишем в окне сервера, моментально появляются в окне клиента.
	\begin{figure}[h!]
		\center{\includegraphics[scale=1]{task1}}
		\caption{Результат работы}
		\label{img:task1}
	\end{figure}
	
	\textbf{Задание} Создать эхо-сервер, взаимодействующий с клиентом посредством pipe.
	
	В программе используется передача дескрипторов через наследование. По причине того, что анонимный канал является полудуплексным, для организации эхо-сервера необходимо создавать 2 канала (для передачи от клиента-серверу и обратно). При этом ненужные дескрипторы каналов закрываются только на стороне сервера (т.к. клиент наследует 4 дескриптора, а явно мы передаем только 2 дескриптора).
	
	Дескрипторы каналов связываются со стандартным вводом и выводом клиентского процесса. Поэтому клиент выводит информацию в поток ошибок (что приведет к выводу в консоль процесса-клиента).
Клиент передает сообщение, например, вида: «message num 1». Сервер передает данное сообщение обратно. Процессы завершаются после передачи 10 сообщений.

	Исходный код программы сервера:
	\lstinputlisting[style=crs_cpp]{pipe_server.cpp}
	
	
	Исходный код программы клиента:
	\lstinputlisting[style=crs_cpp]{pipe_client.cpp}
	
	Результат выполнения программ:
	Сервер:
	\lstinputlisting[style=crs_cpp]{pipe_server.log}
	Клиент:
	\lstinputlisting[style=crs_cpp]{pipe_client.log}

	
\subsection{Именованные каналы}
	Именованные каналы являются дуплексными, ориентированы на обмен сообщениями и обеспечивают взаимодействие через сеть. Кроме того, один именованный канал может иметь несколько открытых дескрипторов. В сочетании с удобными, ориентированными на выполнение транзакций функциями эти возможности делают именованные каналы пригодными для создания клиент-серверных систем. Обмен данными может быть синхронным и асинхронным.
	
	Для создания именованного канала используется функция\\ \textbf{CreateNamedPipe}. При первом вызове функции CreateNamedPipe происходит создание самого именованного канала, а не просто его экземпляра. Закрытие последнего открытого дескриптора экземпляра именованного канала приводит к уничтожению этого экземпляра (обычно существует по одному дескриптору на каждый экземпляр). Уничтожение последнего экземпляра именованного канала приводит к уничтожению самого канала, в результате чего имя канала становится вновь доступным для повторного использования.
	
	После создания именованного канала сервер может ожидать подключения клиента, вызывая функцию \textbf{ConnectNamedPipe}.
	
	Для подключения клиента к именованному каналу применяется функция \textbf{CreateFile}.
	
	С помощью функции \textbf{WaitNamedPipe} процесс может выполнять ожидание момента, когда канал Pipe будет доступен для соединения.
	
	\textbf{Задание} Реализовать между одним клиентом и сервером обмен данными, вводимыми с консоли на стороне клиента и возвращаемыми сервером обратно до получения команды exit.

	Программа-сервер создает именованный канал для двунаправленного использования и ожидает подключения программы-клиента.
	
	Проверяем, корректно ли произошло подключение, затем входим в цикл получения команд от "клиента" с последующими эхо-ответами. При появлении команды exit со стороны клиента, сервер завершает работу, закрывает канал.
	
	Клиент на своей стороне открывает канал, пишет в него и читает эхо-ответ. При вводе exit программа завершается.
	
	Исходный код программы nppipe\_server:
	\lstinputlisting[style=crs_cpp]{npipe_server.cpp}
	
	Исходный код программы npipe\_client:
	\lstinputlisting[style=crs_cpp]{npipe_client.cpp}
	
	Результат выполнения программы приведен на рисунке \ref{img:task3}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task3}}
		\caption{Результат работы}
		\label{img:task3}
	\end{figure}
	
	Запускаем в одном окне сервер (на рис. слева). Он выводит сообщения о том, что канал создан и ожидает подключения клиента. Запускаем в другом окне клиента (справа). Затем на стороне сервера мы получаем уведомление о том, что создано новое подключение, теперь мы можем получать сообщения от клиента.
	
	Клиент после запуска выводит уведомления о том, что он подключился к серверу и ожидает ввода команд в строке cmd> . Вводимые в командной строке символы он пересылает серверу и сразу выводит возвращенный эхо-ответ от него. Для завершения сеанса обмена следует ввести зарезервированную команду exit на стороне клиента, после ее доставки серверу, он завершает работу.
	
	Сервер работает с одним клиентом, поэтому ему не нужно вызывать функции отсоединения клиента (по завершению сервера, клиент тоже завершается).\\
	
	\textbf{Задание} Реализовать между сервером и множеством клиентов обмен данными, вводимыми с консоли на стороне клиента и возвращаемыми сервером обратно до получения команды exit.
	
	Сервер, как и ранее, создает все необходимые ресурсы и переходит в состояние ожидания соединений. Именованный канал создается для чтения и записи. Передача происходит сообщениями, функции передачи и приема блокируются до их окончания.
	
	Клиент после соединения с сервером начинает чтение сообщений с консоли, пока не встретит слово «exit». По данному слову и клиент и сервер завершают свою работу.
	
	Обратить внимание на использование функции WaitNamedPipe, а также на возможность использования количества экземпляров каналов, равного количеству потенциальных клиентов.
	
	Исходный код программы npipe\_server\_bi:
	\lstinputlisting[style=crs_cpp]{npipe_server_bi.cpp}
	
	
	Исходный код программы npipe\_client\_bi:
	\lstinputlisting[style=crs_cpp]{npipe_client_bi.cpp}
	
	Результат выполнения программы приведен на рисунке \ref{img:task4}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task4}}
		\caption{Результат работы}
		\label{img:task4}
	\end{figure}
	
	Для подключения нескольких клиентов сервер был изменен:
	\lstinputlisting[style=crs_cpp]{npipe_server_bi_multi.cpp}
	
	Результат выполнения программы приведен на рисунке \ref{img:task4_2}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task4_2}}
		\caption{Результат работы}
		\label{img:task4_2}
	\end{figure}
	
	Именованные каналы позволяют осуществлять обмен между процессами, выполняющимися на разных компьютерах в сети. Для этого необходимо выполнить определенный ряд условий и настроек. Но сетевые именованные каналы не являются промышленным стандартом и используются в этом качестве скорее как исключение. В ОС семейства Windows это возможно, в отличие, например, от Unix-подобных систем, где обмен данными осуществляется через ядро.
	
	Для совместной работы компьютеры нужно подсоединить к одной домашней группе. Так же необходимо установить поле DACL (Discretionary Access Control List) защиты объекта в NULL (разрешение всем пользователям и группам доступа к объекту). Параметры защиты именованного канала задаются с помощью структуры SECURITYATTRIBUTES, которая указывается последним параметром в функции CreateNamedPipe.
	
	Server для работы по сети:
	\lstinputlisting[style=crs_cpp]{npipe_server_bi_multi_net.cpp}
	
	Client для работы по сети:
	\lstinputlisting[style=crs_cpp]{npipe_client_bi_net.cpp}
	
	Программы были протестированы в локальной сети. Программы npipe\_server\_bi\_multi\_net и npipe\_client\_bi\_net запускались на разных машинах с ОС Windows 10. Компьютеры были объединены в общую домашнюю группу.
	
	Результат работы npipe\_server\_bi\_multi\_net на основной машине приведен на рисунке \ref{img:task5m}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task5m}}
		\caption{Результат работы npipe\_server\_bi\_multi\_net}
		\label{img:task5m}
	\end{figure}
	
	Результат работы npipe\_client\_bi\_net на дополнительной машине приведен на рисунке \ref{img:task5s}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task5s}}
		\caption{Результат работы npipe\_client\_bi\_net}
		\label{img:task5s}
	\end{figure}		
	
	Из-за сложности получения в программе собственных сетевых адресов для подтверждения общения по сети, было решено отловить трафик утилитой WireShark. Трафик отлавливался на основной машине (сторона сервера)
	
		Инициализация общения представлена на рисунке \ref{img:wireinit}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{wire_init}}
		\caption{Инициализация общения сервера и клиента}
		\label{img:wireinit}
	\end{figure}
	
	Пример записи и последующего чтения представлен на рисунке \ref{img:wiremsg}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{wire_msg}}
		\caption{Один цикл обмена данными}
		\label{img:wiremsg}
	\end{figure}
	
	Этап завершения общения представлен на рисунке \ref{img:wireexit}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{wire_exit}}
		\caption{Инициализация общения сервера и клиента}
		\label{img:wireexit}
	\end{figure}
	
	Из записи трафика видно, что общение происходит между двумя машинами, а нагрузка на сеть достаточно велика.
\subsection{Сокеты}
	Возможность взаимодействия с другими системами обеспечивается в Windows поддержкой сокетов (sockets) Windows Sockets — совместимого и почти точного аналога сокетов Berkeley Sockets, де-факто играющих роль промышленного стандарта.
	
	Winsock API поддерживается библиотекой DLL (WS232.DLL), для получения доступа к которой следует подключить к программе библиотеку WS232.LIB. Эту DLL следует инициализировать с помощью нестандартной, специфической для Winsock функции WSAStartup, которая должна быть первой из функций Winsock, вызываемых программой. Когда необходимость в использовании функциональных возможностей Winsock отпадает, следует вызывать функцию WSACleanup. В QtCreator подключение происходит с помощью добавления в файл проекта (.pro) строчки "LIBS += -lws2\_32".
	
	После инициализации библиотеки сокетов можно использовать стандартные функции работы с сокетами.
	
	Взаимодействие в сети осуществляется между клиентом и сервером. Клиент посылает серверу некоторый запрос. Сервер обрабатывает запрос и шлет ответ. Сам по себе сокет – это оконечная точка соединения, которая идентифицируется 4 значениями: IP адрес отправителя, порт отправителя, IP адрес получателя, порт получателя. Порт – идентификатор процесса в ОС с точки зрения сетевого взаимодействия. Порт напрямую связан с протоколом. Например, в ОС могут быть два процесса с одинаковым номером порта, но использующие при этом разные протоколы.
	
	Программа локального обмена сокетами с использованием потокового протокола с установлением соединения (TCP в стеке TCP/IP). Для потоковых протоколов (к которым относится протокол TCP в стеке TCP/IP) необходимо применять средства, позволяющие определить границы сообщений в передаваемых данных, так как данный вид протоколов имеет дело с доставкой только потока байт (при этом гарантируется порядок доставки).
	
	Исходный код программы tcp\_server:
	\lstinputlisting[style=crs_cpp]{tcp_server.cpp}

	Основная функция программы tcp\_client:
	\begin{lstlisting}[style=crs_cpp]
	int main(void) { //используется для инициализации библиотеки сокетов
    WSADATA WSStartData; //Инициализация WinSock и проверка его запуска
    if (WSAStartup(MAKEWORD(2, 0), &WSStartData) != 0) {
        printf("WSAStartup failed with error: %ld\n", GetLastError());
        return 100;
    }
    int er_code=0; // инициализация клиентского сокета
    printf("Client is started.\nTry to create socket\n");
    int client_socket = socket( AF_INET, SOCK_STREAM, 0 );
    printf("socket created successfully\n");
    struct sockaddr_in sin;
    sin.sin_addr.s_addr=inet_addr("127.0.0.1");
    sin.sin_port=htons(7500);
    sin.sin_family=AF_INET; // установливаем TCP-соединение
    printf("try to connect to server\n");
    if(connect(client_socket, (struct sockaddr *) &sin,sizeof(sin))!=0) {
        printf("connect failed with error: %d\n", er_code);
        return SOCKET_ERROR;
    }
    printf("Client connected sucessfully\nEnter msg to send\n---------------------\n");
    char buf[SIZE_OF_BUF]; //буфер для приема и передачи сообщений
    while(1) {
        fgets(buf,SIZE_OF_BUF,stdin);
        printf("client sended msg: %s",buf);
        sendLine(client_socket,buf);
        recvLine(client_socket,buf,SIZE_OF_BUF);
        printf("get msg from serv: \"%s\"\n**********************\n",buf);
    } // заканчиваем работу с сокетом клиента
    closesocket(client_socket);
    return 0;
}	\end{lstlisting}
	
	Результат выполнения программы приведен на рисунке \ref{img:task6}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task6}}
		\caption{Результат работы}
		\label{img:task6}
	\end{figure}
	
	Для поддержки подключения нескольких клиентов код сервера был немного изменен:
	\begin{lstlisting}[style=crs_cpp]
DWORD WINAPI threadHandler(LPVOID param){
	SOCKET client_socket = (SOCKET)param;
	if (client_socket == INVALID_SOCKET) {
		printf("error with accept socket. GetLasterror= %d\n", GetLastError());
		return 1003;
	}
	char buf[SIZE_OF_BUF]; //буфер приема и передачи сообщения 
	int readbytes; //число прочитанных байт 
	while (1) {
		if ((readbytes = recvLine(client_socket, buf, SIZE_OF_BUF)) == 0) {
			printf("Connection refused\n");
			break;
		}
		else if (readbytes == -1) {
			printf("buf is small\n");
			return 2000;
		}
		printf("get msg from client \"%s\" with size= %d\n", buf, readbytes);
		sendLine(client_socket, buf); //sendn(client_socket,buf,readbytes,0); //шлем сообщение обратно клиенту
		if (strncmp(buf, "exit", 4) == 0) break;
	}
	closesocket(client_socket);
	return 0;
}
//............
// main:
	while (SOCKET client_socket = accept(server_socket, (struct sockaddr*)&from, &fromlen)){
		HANDLE t;
		t = CreateThread(NULL, 0, threadHandler, (LPVOID)client_socket, 0, NULL);
	}
	closesocket(server_socket);
	\end{lstlisting}
	
	С помощью сокетов часто реализовывают сетевые приложения. Для этого необходимо внести незначительные изменения в код сервера и клиента: слушающий сокет сервера необходимо привязывать к адресу \texttt{INADDR\_ANY}, чтобы он мог принимать соединения с любых адресов; клиенту необходимо указать IP адрес компьютера, на котором запущен сервер.
	
	Результат выполнения сервера и двух клиентов рис. \ref{img:task6_2}. По этому рисунку видно, что общение происходило между разными компьютерами в сети.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task6_2}}
		\caption{Основная машина}
		\label{img:task6_2}
	\end{figure}	
	
	Результат выполнения двух удалённых клиентов \ref{img:task6_3}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.5]{task6_3}}
		\caption{Дополнительная (удалённая) машина}
		\label{img:task6_3}
	\end{figure}
	
Так мы видим, что с одним сервером могут работать сразу несколько клиентов, причём доступ открыт и из сети. Открытие доступа требует дополнительных прав при запуске программы, но получив права, сервер успешно запускается. Обеспечение доступа всех клиентов к общему ресурсу с помощью мьютекса является самым простым и надёжным решением, однако наименее эффективным.
	
\subsection{Сигналы в Windows}
	Данное средство IPC в Windows не поддерживается. Однако, например, консольному приложению можно посылать сигналы CTRL+C и CTRL+BREAK. Система может посылать приложению сигналы: \texttt{CTRL\_CLOSE\_EVENT,\\ CTRL\_LOGOFF\_EVENT и CTRL\_SHUTDOWN\_EVENT}, когда пользователь закрывает консоль, выходит из системы, или когда система завершается. По получению данных сигналов процесс может произвести корректное завершение.
	
	С помощью функции SetConsoleCtrlHandler можно установить обработчик на данные сигналы, но отправить сигнал другому приложению мы не можем. 
	
	Зарегистрированный обработчик должен проверять тип сигнала на возможность его обработки. Обработчики сигналов объединены в список. Когда приходит сигнал, вызывается последний зарегистрированный обработчик (при этом запускается отдельный поток). Если этот обработчик возвращает FALSE (он не обрабатывает этот сигнал), то вызывается следующий. Если все обработчики вернули FALSE, вызовется обработчик по-умолчанию, который по-умолчанию завершает процесс.
	
	В качестве примера рассмотрим код из msdn. В нем происходит перехват сигналов CTRL+C, CTRL+BREAK. При этом обработчик смотрит, какой сигнал ему передан, и выводит его название. В качестве звуковой индикации работы приложение вызывает функцию Beep. Данная функция воспроизводит звуковой сигнал через динамик консоли с разной частотой и длительностью, задаваемыми ей через параметры.
	
	В функции main регистрируется обработчик сигналов, затем главный поток работает в бесконечном цикле.
	
	Искодный код:
	\begin{lstlisting}[style=crs_cpp]
#include <windows.h> 
#include <stdio.h> 

BOOL CtrlHandler( DWORD fdwCtrlType ) { 
	switch( fdwCtrlType )  { 
		// Handle the CTRL-C signal.
	case CTRL_C_EVENT: 
		printf( "Ctrl-C event\n\n" ); 
		Beep( 750, 300 ); 
		return( TRUE ); //CTRL-CLOSE: confirm that the user wants to exit.
	case CTRL_CLOSE_EVENT: 
		Beep( 600, 200 ); 
		printf( "Ctrl-Close event\n\n" );
		return(TRUE); // Pass other signals to the next handler. 
	case CTRL_BREAK_EVENT:
		Beep( 900, 200 );
		printf( "Ctrl-Break event\n\n" );
		return FALSE;
	case CTRL_LOGOFF_EVENT: 
		Beep( 1000, 200 );
		printf( "Ctrl-Logoff event\n\n" );
		return FALSE;
	case CTRL_SHUTDOWN_EVENT:
		Beep( 750, 500 ); 
		printf( "Ctrl-Shutdown event\n\n" ); 
		return FALSE; 
	default:
		return FALSE; 
	}
} 

int main( void ) {
	if( SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlHandler, TRUE ) ) {
		printf( "\nThe Control Handler is installed.\n" ); 
		printf( "\n -- Now try pressing Ctrl+C or Ctrl+Break, or" ); 
		printf( "\n try logging off or closing the console...\n" ); 
		printf( "\n(...waiting in a loop for events...)\n\n" ); 
		while( 1 ){ } 
	} else { 
		printf( "\nERROR: Could not set control handler");
		return 1; 
	} 
	return 0; 
}
	\end{lstlisting}
	
	Результат выполнения программы приведен на рисунке \ref{img:task7}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task7}}
		\caption{Результат работы}
		\label{img:task7}
	\end{figure}
	
\subsection{Разделяемая память}
	Потоки одного процесса могут разделять общую память этого процесса. У каждого процесса – свое изолированное адресное пространство. Кроме рассмотренных выше средств передачи информации между процессами или потоками разных процессов, одно из наиболее эффективных – использование общей памяти, доступ к которой обеспечивается со стороны каждого процесса. ОС Windows поддерживает такое средство, как именованная, совместно используемая память.
Приведем системные функции, которые позволяют запрограммировать такое взаимодействие.
	
	Первый участвующий в обмене информацией процесс создает объект "проекция файла" при помощи вызова функции CreateFileMapping(). Используя флажок \texttt{PAGE\_READWRITE}, задается доступ по чтению и записи в память через представление данных файла в адресном пространстве процесса. Процесс затем использует дескриптор объекта "проекция файла", возвращаемый функцией CreateFileMapping(), при вызове функции MapViewOfFile(). Эта функция создает представление файла в адресном пространстве процесса и возвращает указатель на представление данных файла для их дальнейшего использования.
	
	Другой процесс может получить доступ к тем же данным при помощи вызова функции OpenFileMapping() с тем же самым именем, что и первый процесс, а затем использовать функцию MapViewOfFile(), чтобы получить свой указатель на представление данных файла.
	
	Для записи данных в память используется функция CopyMemory(), первый аргумент которой – возвращаемый функцией MapViewOfFile() указатель, а следующие – характеризуют записываемые данные.
	
	Когда процессу больше не нужен доступ к объекту "проекция файла в память", он должен вызвать функцию CloseHandle() для дальнейшего освобождения ресурса. При условии, что все дескрипторы закрыты (не осталось процессов, использующих этот ресурс), система может освободить секцию файла подкачки, используемого объектом.
	
	\textbf{Задание} Создать программу, в которой первый процесс генерирует случайное число и записывает его в буфер, доступный второму процессу, откуда он его и считывает с последующим выводом.
	
	Исходный код первой:
	\begin{lstlisting}[style=crs_cpp]
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#define BUF_SIZE 256
TCHAR szName[] = TEXT("MyFileMappingObject");
TCHAR szMsg[] = TEXT("Message from first process");
HANDLE WINAPI mutex;
void main()
{
	HANDLE hMapFile;
	LPCTSTR pBuf;
	mutex = CreateMutex(NULL, false, TEXT("SyncMutex"));
	// create a memory, wicth two proccess will be working
	hMapFile = CreateFileMapping(
		INVALID_HANDLE_VALUE, // использование файла подкачки
		NULL, // защита по умолчанию
		PAGE_READWRITE, // доступ к чтению/записи
		0, // макс. размер объекта
		BUF_SIZE, // размер буфера
		szName); // имя отраженного в памяти объекта
	if (hMapFile == NULL || hMapFile == INVALID_HANDLE_VALUE)
	{
		printf("Не может создать отраженный в памяти объект (%d).\n",
			GetLastError());
		return;
	}
	pBuf = (LPTSTR)MapViewOfFile(hMapFile, //дескриптор проецируемого в памяти объекта
		FILE_MAP_ALL_ACCESS, // разрешение чтения/записи(режим доступа)
		0, //Старшее слово смещения файла, где начинается отображение
		0, //Младшее слово смещения файла, где начинается отображение
		BUF_SIZE); //Число отображаемых байтов файла
	if (pBuf == NULL)
	{
		printf("Представление проецированного файла невозможно (%d).\n",
			GetLastError());
		return;
	}
	int i = 0;
	while (true)
	{
		i = rand();
		itoa(i, (char *)szMsg, 10);
		WaitForSingleObject(mutex, INFINITE);
		CopyMemory((PVOID)pBuf, szMsg, sizeof(szMsg));
		printf("write message: %s\n", (char *)pBuf);
		//Sleep(1000); //необходимо только для отладки - для удобства представления и анализа //результатов
		ReleaseMutex(mutex);
	}
	// освобождение памяти и закрытие описателя handle
	UnmapViewOfFile(pBuf);
	CloseHandle(hMapFile);
	CloseHandle(mutex);
}
	\end{lstlisting}	
	
	Исходный код второй программы:
	\begin{lstlisting}[style=crs_cpp]
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#define BUF_SIZE 256
#define TIME 15 // number of reading operation in this process
TCHAR szName[] = TEXT("MyFileMappingObject");
HANDLE WINAPI mutex;
void main()
{
	HANDLE hMapFile;
	LPCTSTR pBuf;
	mutex = OpenMutex(
		MUTEX_ALL_ACCESS, // request full access
		FALSE, // handle not inheritable
		TEXT("SyncMutex")); // object name
	if (mutex == NULL)
		printf("OpenMutex error: %d\n", GetLastError());
	else printf("OpenMutex successfully opened the mutex.\n");
	hMapFile = OpenFileMapping(
		FILE_MAP_ALL_ACCESS, // доступ к чтению/записи
		FALSE, // имя не наследуется
		szName); // имя "проецируемого " объекта
	if (hMapFile == NULL)
	{
		printf("Невозможно открыть объект проекция файла (%d).\n", GetLastError());
		return;
	}
	pBuf = (LPTSTR)MapViewOfFile(hMapFile, // дескриптор "проецируемого" объекта
		FILE_MAP_ALL_ACCESS, // разрешение чтения/записи
		0,
		0,
		BUF_SIZE);
	if (pBuf == NULL)
	{
		printf("Представление проецированного файла (%d) невозможно .\n", GetLastError());
		return;
	}
	for (int i = 0; i<TIME; i++)
	{
		WaitForSingleObject(mutex, INFINITE);
		printf("read message: %s\n", (char *)pBuf);
		ReleaseMutex(mutex);
	}
	UnmapViewOfFile(pBuf);
	CloseHandle(hMapFile);
}
	\end{lstlisting}
	
	Результат выполнения программы приведен на рисунке \ref{img:task8}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task8}}
		\caption{Результат работы}
		\label{img:task8}
	\end{figure}
	
	Для организации синхронизации доступа к памяти в данном примере рассматривается использование мьютексов. В первом процессе создается именованный мьютекс, который "защищает" критические участки кода, в данном случае - запись в общую разделяемую память.
	
	Записываемая в буфер информация - это случайное число, которое генерируется функцией rand()перед каждой записью.
	
	Второй процесс открывает ранее созданный и именованный первым процессом мьютекс.
	
\subsection{Почтовые слоты}
	MailSlot – механизм синхронизации, иначе называемый «почтовый ящик». Каждый слот реализуется как псевдофайл в оперативной памяти и содержит некоторое количество записей («сообщений»), которые могут быть прочтены всеми компьютерами в сетевом домене. Общий размер данных не дможет превышать 64K. В отличие от дисковых файлов, файлы MailSlot временные. Когда все указатели на MailSlot закрываются, MailSlot и все данные, которые он содержит, удаляются. Для обмена посредством MailSlot создается клиент-серверное приложение. MailSlot сервер – является процессом, который создает и владеет MailSlot. При создании сервер получает указатель, используемый затем при чтении или записи данных им самим или другим процессом, получившим указатель на MailSlot. Создать слот можно только локально, а получать доступ (обращаться) и локально и удалённо.
	
	Для демонстрации работы с почтовыми слотами были написаны программы сервера и клиента.	Исходный сервера:
	\begin{lstlisting}[style=crs_cpp]
#include <windows.h>
#include <stdio.h>
#include <conio.h>

int main() {
	// Код возврата из функций
	BOOL   fReturnCode;
	// Размер сообщения в байтах
	DWORD  cbMessages;
	// Количество сообщений в канале Mailslot
	DWORD  cbMsgNumber;
	// Идентификатор канала Mailslot
	HANDLE hMailslot;
	// Имя создаваемого канала Mailslot
	LPCWSTR  lpszMailslotName = L"\\\\.\\mailslot\\$Channel$";
	// Буфер для передачи данных через канал
	char   szBuf[512];
	// Количество байт данных, принятых через канал
	DWORD  cbRead;
	
	// Создаем канал Mailslot, имеющий имя lpszMailslotName
	hMailslot = CreateMailslot(
		lpszMailslotName, 0,
		MAILSLOT_WAIT_FOREVER, NULL);

	// Если возникла ошибка, выводим ее код и зваершаем
	// работу приложения
	if (hMailslot == INVALID_HANDLE_VALUE)
	{
		fprintf(stdout, "CreateMailslot: Error %ld\n",
			GetLastError());
		getch();
		return 0;
	}

	// Выводим сообщение о создании канала
	fprintf(stdout, "Mailslot created\n");

	// Цикл получения команд через канал
	while (1)
	{
		// Определяем состояние канала Mailslot
		fReturnCode = GetMailslotInfo(
			hMailslot, NULL, &cbMessages,
			&cbMsgNumber, NULL);

		if (!fReturnCode)
		{
			fprintf(stdout, "GetMailslotInfo: Error %ld\n",
				GetLastError());
			getch();
			break;
		}

		// Если в канале есть Mailslot сообщения,
		// читаем первое из них и выводим на экран
		if (cbMsgNumber != 0)
		{
			if (ReadFile(hMailslot, szBuf, 512, &cbRead, NULL))
			{
				// Выводим принятую строку на консоль 
				printf("Received: <%s>\n", szBuf);

				// Если пришла команда "exit", 
				// завершаем работу приложения
				if (!strcmp(szBuf, "exit"))
					break;
			}
			else
			{
				fprintf(stdout, "ReadFile: Error %ld\n",
					GetLastError());
				getch();
				break;
			}
		}

		// Выполняем задержку на  500 миллисекунд
		Sleep(500);
	}

	// Перед завершением приложения закрываем
	// идентификатор канала Mailslot
	CloseHandle(hMailslot);
	return 0;
}
	\end{lstlisting}	
	
	Исходный код клиента:
	\begin{lstlisting}[style=crs_cpp]
#include <windows.h>
#include <stdio.h>
#include <conio.h>

DWORD main(int argc, char *argv[])
{
	// Идентификатор канала Mailslot
	HANDLE hMailslot;
	// Буфер для имени канала Mailslot
	LPCWSTR   szMailslotName = L"\\\\.\\mailslot\\$Channel$";
	// Буфер для передачи данных через канал
	char   szBuf[512];
	// Количество байт, переданных через канал
	DWORD  cbWritten;
	// Создаем канал с процессом MSLOTS
	hMailslot = CreateFile(
		szMailslotName, GENERIC_WRITE,
		FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

	// Если возникла ошибка, выводим ее код и 
	// завершаем работу приложения
	if (hMailslot == INVALID_HANDLE_VALUE)
	{
		fprintf(stdout, "CreateFile: Error %ld\n",
			GetLastError());
		getch();
		return 0;
	}

	// Выводим сообщение о создании канала
	fprintf(stdout, "\nConnected. Type 'exit' to terminate\n");

	// Цикл посылки команд через канал
	while (1)
	{
		// Выводим приглашение для ввода команды
		printf("cmd>");

		// Вводим текстовую строку
		gets(szBuf);

		// Передаем введенную строку серверному процессу
		// в качестве команды
		if (!WriteFile(hMailslot, szBuf, strlen(szBuf) + 1,
			&cbWritten, NULL))
			break;

		// В ответ на команду "exit" завершаем цикл
		// обмена данными с серверным процессом
		if (!strcmp(szBuf, "exit"))
			break;
	}

	// Закрываем идентификатор канала
	CloseHandle(hMailslot);
	return 0;
}
	\end{lstlisting}
	
	Результат выполнения программы приведен на рисунке \ref{img:task9}.
	\begin{figure}[h!]
		\center{\includegraphics[scale=0.8]{task9}}
		\caption{Результат работы}
		\label{img:task9}
	\end{figure}
	
	Используя почтовые слоты можно передавать данные между компьютерами в локальной сети. При создании почтовых слотов с одинаковым именем на нескольких компьютерах домена возможна широковещательная рассылка сообщений клиентов. Один клиентский процесс может посылать сообщения сразу всем этим серверным процессам.

\section{Вывод}
	В ОС Windows реализовано несколько средств межпроцессного взаимодействия. Некоторые из них совпадают с IPC в UNIX: неименованные и именованные каналы, сокеты, разделяемая память. Некоторые уникальны, например, почтовые слоты.
	
	Неименованные каналы Windows обеспечивают однонаправленное (полудуплексное) посимвольное межпроцессное взаимодействие. Каждый канал имеет два дескриптора: дескриптор чтения и дескриптор записи. Дескрипторы каналов часто бывают наследуемыми. Чтобы канал можно было использовать для IPC, должен существовать еще один процесс, и для этого процесса требуется один из дескрипторов канала. 
Анонимные каналы обеспечивают только однонаправленное взаимодействие. Для двухстороннего взаимодействия необходимы два канала. 

	Именованные каналы обеспечивают межпроцессное взаимодействие между сервером и одним или несколькими клиентами. Они предоставляют больше функциональных возможностей, чем анонимные каналы, которые обеспечивают межпроцессное взаимодействие на локальном компьютере. Именованные каналы поддерживают дуплексную связь по сети, несколько экземпляров сервера, взаимодействие, основанное на сообщениях и олицетворение клиента, что позволяет подключаемым процессам использовать собственные наборы разрешений на удаленных серверах. Использовать именованные каналы для связи по сети возможно только для компьютеров с ОС Windows, подключенных к одной домашней группе. Поэтому, именованные каналы редко используются для клиент-серверных приложений.
	
	Возможность взаимодействия с другими системами обеспечивается в Windows поддержкой сокетов. Сокет – это оконечная точка соединения, которая идентифицируется 4 значениями: IP адрес отправителя, порт отправителя, IP адрес получателя, порт получателя. 
	
	Механизм сигналов как IPC отсутствует в ОС Windows. Процессы не могут отправлять сигналы другим процессам для обмена информацией. Присутствует 2 сигнала которые пользователь может отправлять приложению с клавиатуры: Ctrl+C и Ctrl+Break. Так же система может посылать приложению сигналы когда пользователь закрывает консоль, выходит из системы или когда система завершается.
	
	ОС Windows поддерживает такое средство, как именованная, совместно используемая память. Разделяемая память позволяет обмениваться информацией между двумя процессами.
	
	MailSlot – механизм синхронизации, иначе называемый «почтовый ящик». Каждый слот реализуется как псевдофайл в оперативной памяти и содержит некоторое количество записей («сообщений»), которые могут быть прочтены всеми компьютерами в сетевом домене. Используя почтовые слоты можно передавать данные между компьютерами в локальной сети. При создании почтовых слотов с одинаковым именем на нескольких компьютерах домена возможна широковещательная рассылка сообщений клиентов. Один клиентский процесс может посылать сообщения сразу всем этим серверным процессам.

\section{Список литературы}
\begin{itemize}
\item Душутина Е.В.  Межпроцессные взаимодействия в операционных системах – СПб, 2014 г, 136 с.
\item Душутина Е.В.  Практические вопросы оазработки системных приложений – СПб, 2015 г, 165 с.
\item Таненбаум Э., Бос Х. Современные операционные системы. 4-е изд. – СПб.: Питер, 2015 – 1120 с.
\end{itemize}
	

\end{document}

