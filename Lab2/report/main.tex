\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\usepackage{color}
\usepackage{here}
\usepackage{listings}
\lstset{ %
language=bash,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm] % название работы, затем отступ 0,6см
\large Отчет по лабораторной работе №2\\[0.1cm]
\large Файловые системы\\[5cm]
% тема работы, затем отступ 3,7см
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство

\section{Типы файлов}
\subsection{Задание:} Ознакомиться с типами файлов исследуемой ФС.
Применяя утилиту ls, отфильтровать по одному примеру каждого типа файла используемой вами ФС. Комбинируя различные ключи утилиты рекурсивно просканировать все дерево, анализируя крайнюю левую позицию выходной информации полученной посредством ls –l. Результат записать в выходной файл с указанием полного пути каждого примера. Выполнить задание сначала в консоли построчно, выбирая необходимые сочетания ключей  (в командной строке), а затем оформить как скрипт с задаваемым в командной строке именем файла как параметр.

\subsection{Решение в командной строке:}
\lstinputlisting{../listings/types_nr}
\begin{itemize}
\item \textbf{cd /} - переход в корневую директорию
\item \textbf{ls -ld \$PWD**/* 2>/dev/null} - вызов \textbf{ls} отдельно для всех файлов в и ниже текущей директории и перенаправление потока ошибок "в никуда"
\item \textbf{grep \^{} [-dplscb]} - избавление от всех строк, что не начинаются одним из символов \textit{-dplscb} .
\item \textbf{sort -k1.1,1.1} - сортировка по первому символу строки
\item \textbf{uniq -w1} - оставляем строки с уникальным первым символом
\item \textbf{cd -} - возврат в исходную директорию
\end{itemize}

Однако, такое решение, являясь абсолютно работоспособным для оболочки \textbf{zsh}, не подходит для оболочки \textbf{bash}, так как в последней команда \$PWD**/* не будет рекурсивной, так как эквивалентна \$PWD*/*, а это только файлы поддиректорий (первого уровня) активной директории.

Поскольку силами команды \textbf{ls} больше нет способа вывести полный путь в строке характеристик файла, модифицируем вывод самостоятельно.

\subsection{Полное решение в командной строке:}
\lstinputlisting{../listings/types_r}
Данная команда отличается тем, что исходный(корневой) каталог мы указывает непосредственно утилите \textbf{ls} и она сама ответственна за рекурсивность, а не передаваемый ей параметр. Но главным отличием является ступень конвейера, ответственная за модификацию вывода \textbf{ls}. С помощью утилиты \textbf{awk} реализуется скрипт, запоминающий, какую директорию просматривает \textbf{ls}, и добавляющий этот путь к полю имени файла (последнему или предпредпоследнему, если это символьная ссылка).

\subsection{Скрипт:}
\lstinputlisting{../listings/types}
Уже рассмотренная команда обёрнута в минимальный набор и добавлен выбор файла со значением по умолчанию.

Рассмотрим примеры работы:
\lstinputlisting{../listings/types_examp}
Из примера видно, что в первом случае происходит запись в файл по умолчанию, а во втором - в указанный.
\section{Жесткие ссылки} \textbf{Задание:} Получить все жесткие ссылки на заданный файл, находящиеся в разных каталогах пользовательского пространства (разными способами, не применяя утилиты file и find). Использовать конвейеризацию и фильтрацию. Оформить в виде скрипта. 

\subsection{Решение в командной строке:}
\lstinputlisting{../listings/hl_tty}
Как видно из примера, мне для реализации данной задачи в терминале потребовалось две команды и одна переменная, их связывающая. Поиск происходит в пределах домашнего каталога пользователя.

\subsection{Скрипт:}
\lstinputlisting{../listings/hl}
Сначала сохраняем inode файла в переменную, а потом проверяем всю домашнюю директорию пользователя, запустившего скрипт на наличие файлов с таким же inode.

Рассмотрим пример работы:
\lstinputlisting{../listings/hl_examp}
Из примера видно, что что все возможные варианты поведения скрипта для первого аргумента (а остальные скриптом не обрабатываются) корректно обрабатываются. И в случае существования файла и наличия его inode в домашней директории пользователя, скрипт его/их выведет.
\section{Создание символьных ссылок}
\subsection{Задание:} Проанализировать все возможные способы формирования символьных ссылок (ln, link,cp и т.д.), продемонстрировать их экспериментально.
\subsection{Утилиты}
\subsubsection{ln}

Утилита \textbf{ln} по умолчанию создает жёсткие ссылки, но флаг -s позволяет создать символьную ссылку. Рассмотрим пример:
\lstinputlisting{../listings/ls}

\subsubsection{link}

Утилита \textbf{link} - вызывает функцию создания жёстких ссылок (только жёстких). Используется только с двумя аргументами: имя исходного файла и имя ссылки. Рассмотрим пример:
\lstinputlisting{../listings/link}

\subsubsection{cp}

Утилита \textbf{cp} создана для копирования файлов, а не создания ссылок. Однако, как уже было продемонстрировано в первом отчёте, создать символьные и жёсткие ссылки можно c помощью флагов -s и -l, соответственно. Рассмотрим пример:
\lstinputlisting{../listings/cp}

\subsection{Отображение}
В примерах выше, мы видели, что утилита \textbf{ls} указывает файл, на который указывает ссылка. Но путь к этому относителен по отношению к самой ссылке. Рассмотрим на примере утилиты \textbf{ls} и \textbf{cp}:
\lstinputlisting{../listings/symlinkpath}
Из примера видно, что утилита \textbf{ln} создаёт ссылку на файл относительно директории вызова утилиты. Поэтому, ссылка sym\_link1, помещённая на директорию ниже, указывала на файл, находящийся на директорию ниже. Эту особенность мы обошли с помощью флага -r, скорректировавшего путь относительно местоположения ссылки. А утилита \textbf{cp} не позволяет создавать символьные ссылки в директории, отличной от текущей.

До этого мы пользовались общей утилитой \textbf{ls} для просмотра ссылок, но есть и специализированные - \textbf{readlink} и \textbf{realpath}. Рассмотрим:
\lstinputlisting{../listings/readlink}
Из приведённого видно, что для ссылки можно получить и полный путь.
\section{Символьные ссылки} Предложить скрипт, подсчитывающий и перечисляющий все полноименные символьные ссылки на файл, размещаемые в разных местах файлового дерева. Получить все символьные ссылки на заданный в качестве входного параметра файл, не используя file.

\lstinputlisting{../listings/sym_search}

Первой командой данного скрипта мы узнаём и запоминаем полный путь до указанного нами файла. А первые шаги поиска ссылок нам уже известны: модификация вывода утилиты \textbf{ls}, добавляющая полный путь к файлам. После чего выделяются только ссылки и по полному пути к ним утилитой \textbf{realpath} идентифицируется файл, на который они ссылаются. Этот результат файл сравнивается с запомненным в начале скрипта по полному пути и имени.

Данный скрип не считает количество ссылок, а всего лишь выводит их. Но этот функционал легко добавить конвейером, что сейчас и рассмотрим.
\lstinputlisting{../listings/sym_search_examp}
Из приведённого видно, что утилита \textbf{wc} позволяет посчитать количество строк, что нам и требуется. Таким образом мы узнали, что у нас есть 3 символьных ссылки на этот файл.

\section{Find} Изучить утилиту find, используя ее ключи получить расширенную информацию о всех типах файлов. Создать примеры вложенных команд.

\section{Заголовок файла} Проанализировать содержимое заголовка файла, а также файла-каталога с помощью утилит od  и  *dump. 
Если доступ к файлу-каталогу возможен (для отдельных модификаций POSIX-совместимых ОС), проанализировать изменение его содержимого при различных операциях над элементами, входящими в его состав (файлами и подкаталогами).  

\section{Максимальное количество записей в каталоге} Определить максимальное количество записей в каталоге. 
Изменить размер каталога, варьируя количество записей (для этого создать программу, порождающую новые файлы и каталоги, а затем удаляющую их, предусмотрев промежуточный и конечный вывод информации о размере подопытного каталога). 

\section{Каталоги паролей} Ознакомиться с содержимым /etc/passwd, /etc/shadow, с утилитой /usr/bin/passwd, проанализировать права доступа к этим файлам.

\section{Права владения и доступа} Исследовать права владения и доступа, а также их сочетаемость
\subsection{ Привести} примеры применения утилит chmod, chown к специально созданному для этих целей отдельному каталогу с файлами. 
\subsection{ Расширить} права исполнения экспериментального файла с помощью флага SUID. 
\subsection{ Экспериментально} установить, как формируются итоговые права на использование файла, если права пользователя и группы, в которую он входит, различны.
\subsection{ Сопоставить} возможности исполнения наиболее часто используемых операций, варьируя правами доступа к файлу и каталогу.

\section{«Программа-шлюз» } Разработать «программу-шлюз» для доступа к файлу другого пользователя при отсутствии прав на чтение информации из этого файла. Провести эксперименты для случаев, когда пользователи принадлежат одной и разным группам. Сравнить результаты. Для выполнения задания применить подход, аналогичный для обеспечения функционирования утилиты /usr/bin/passwd (манипуляции с правами доступа, флагом SUID, а также размещением файлов).

\section{ df и аналоги} Применяя утилиту df и аналогичные ей по функциональности утилиты, а также информационные файлы типа fstab, mtab и т.п. получить информацию о файловых системах, возможных для монтирования, а также установленных на компьютере реально. 
\subsection{ Привести} информацию об исследованных утилитах и информационных файлах с анализом их содержимого и форматов. 
\subsection{ Привести} образ диска с точки зрения состава и размещения всех ФС на испытуемом компьютере, а также образ полного дерева ФС, включая присоединенные ФС съемных и несъемных носителей. Проанализировать и указать формат таблицы монтирования.
\subsection{ Привести} «максимально возможное» дерево ФС, проанализировать, где это указывается

\section{ File} Проанализировать и пояснить принцип работы утилиты file.  
\subsection{ Привести} алгоритм её функционирования на основе информационной базы, размещение и полное имя которой указывается в описании утилиты в технической документации ОС (как правило, /usr/share/file/magic.*), а также содержимого заголовка файла, к которому применяется утилита. Определить, где находятся магические числа и иные характеристики, идентифицирующие тип файла, применительно к исполняемым файлам, а также файлам других типов. 
\subsection{ Утилиту} file выполнить с разными ключами. 
\subsection{ Привести} экспериментальную попытку с добавлением в базу собственного типа файла и его дальнейшей идентификацией. Описать эксперимент и привести последовательность действий для расширения функциональности утилиты file и возможности встраивания дополнительного типа файла в ФС (согласовать содержимое информационной базы и заголовка файла нового типа).

\end{document}