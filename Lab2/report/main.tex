\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{indentfirst} % включить отступ у первого абзаца
\usepackage{listings}
\usepackage{color}
\usepackage{here}
\usepackage{listings}
\lstset{ %
language=bash,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},          % if you want to add a comment within your code
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\usepackage[left=2.5cm, top=2cm, right=2cm, bottom=2cm, nohead]{geometry}

\begin{document}
\begin{titlepage} % начало титульной страницы

\begin{center} % включить выравнивание по центру

\large Санкт-Петербургский Политехнический Университет Петра Великого\\
\large Институт компьютерных наук и технологий \\
\large Кафедра компьютерных систем и программных технологий\\[6cm]
% название института, затем отступ 4,5см

\huge Операционные системы и среды\\[0.5cm] % название работы, затем отступ 0,6см
\large Отчет по лабораторной работе №2\\[0.1cm]
\large Файловые системы\\[5cm]
% тема работы, затем отступ 3,7см
\end{center}

\begin{flushright}
\begin{minipage}{0.5\textwidth}
\begin{flushright}
\textbf{Работу выполнил:}

Петров Владислав

{Группа:} 43501/4\\


\textbf{Преподаватель:} 

Душутина Елена Владимировна
\end{flushright}
\end{minipage} % конец врезки
\end{flushright} % конец выравнивания по левому краю

\vfill % заполнить всё доступное ниже пространство

\begin{center}

\large Санкт-Петербург\\
\large \the\year % вывести дату

\end{center} % закончить выравнивание по центру

\thispagestyle{empty} % не нумеровать страницу
\end{titlepage} % конец титульной страницы

\vfill % заполнить всё доступное ниже пространство

\section{Типы файлов}
\subsection{Задание:} Ознакомиться с типами файлов исследуемой ФС.
Применяя утилиту ls, отфильтровать по одному примеру каждого типа файла используемой вами ФС. Комбинируя различные ключи утилиты рекурсивно просканировать все дерево, анализируя крайнюю левую позицию выходной информации полученной посредством ls –l. Результат записать в выходной файл с указанием полного пути каждого примера. Выполнить задание сначала в консоли построчно, выбирая необходимые сочетания ключей  (в командной строке), а затем оформить как скрипт с задаваемым в командной строке именем файла как параметр.

\subsection{Решение в командной строке:}
\lstinputlisting{../listings/types_nr}
\begin{itemize}
\item \textbf{cd /} - переход в корневую директорию
\item \textbf{ls -ld \$PWD**/* 2>/dev/null} - вызов \textbf{ls} отдельно для всех файлов в и ниже текущей директории и перенаправление потока ошибок "в никуда"
\item \textbf{grep \^{} [-dplscb]} - избавление от всех строк, что не начинаются одним из символов \textit{-dplscb} .
\item \textbf{sort -k1.1,1.1} - сортировка по первому символу строки
\item \textbf{uniq -w1} - оставляем строки с уникальным первым символом
\item \textbf{cd -} - возврат в исходную директорию
\end{itemize}

Однако, такое решение, являясь абсолютно работоспособным для оболочки \textbf{zsh}, не подходит для оболочки \textbf{bash}, так как в последней команда \$PWD**/* не будет рекурсивной, так как эквивалентна \$PWD*/*, а это только файлы поддиректорий (первого уровня) активной директории.

Поскольку силами команды \textbf{ls} больше нет способа вывести полный путь в строке характеристик файла, модифицируем вывод самостоятельно.

\subsection{Полное решение в командной строке:}
\lstinputlisting{../listings/types_r}
Данная команда отличается тем, что исходный(корневой) каталог мы указывает непосредственно утилите \textbf{ls} и она сама ответственна за рекурсивность, а не передаваемый ей параметр. Но главным отличием является ступень конвейера, ответственная за модификацию вывода \textbf{ls}. С помощью утилиты \textbf{awk} реализуется скрипт, запоминающий, какую директорию просматривает \textbf{ls}, и добавляющий этот путь к полю имени файла (последнему или предпредпоследнему, если это символьная ссылка).

\subsection{Скрипт:}
\lstinputlisting{../listings/types}
Уже рассмотренная команда обёрнута в минимальный набор и добавлен выбор файла со значением по умолчанию.

Рассмотрим примеры работы:
\lstinputlisting{../listings/types_examp}
Из примера видно, что в первом случае происходит запись в файл по умолчанию, а во втором - в указанный.
\section{Жесткие ссылки} \textbf{Задание:} Получить все жесткие ссылки на заданный файл, находящиеся в разных каталогах пользовательского пространства (разными способами, не применяя утилиты file и find). Использовать конвейеризацию и фильтрацию. Оформить в виде скрипта. 

\subsection{Решение в командной строке:}
\lstinputlisting{../listings/hl_tty}
Как видно из примера, мне для реализации данной задачи в терминале потребовалось две команды и одна переменная, их связывающая. Поиск происходит в пределах домашнего каталога пользователя.

\subsection{Скрипт:}
\lstinputlisting{../listings/hl}
Сначала сохраняем inode файла в переменную, а потом проверяем всю домашнюю директорию пользователя, запустившего скрипт на наличие файлов с таким же inode.

Рассмотрим пример работы:
\lstinputlisting{../listings/hl_examp}
Из примера видно, что что все возможные варианты поведения скрипта для первого аргумента (а остальные скриптом не обрабатываются) корректно обрабатываются. И в случае существования файла и наличия его inode в домашней директории пользователя, скрипт его/их выведет.
\section{Создание символьных ссылок}
\subsection{Задание:} Проанализировать все возможные способы формирования символьных ссылок (ln, link,cp и т.д.), продемонстрировать их экспериментально.
\subsection{Утилиты}
\subsubsection{ln}

Утилита \textbf{ln} по умолчанию создает жёсткие ссылки, но флаг -s позволяет создать символьную ссылку. Рассмотрим пример:
\lstinputlisting{../listings/ls}

\subsubsection{link}

Утилита \textbf{link} - вызывает функцию создания жёстких ссылок (только жёстких). Используется только с двумя аргументами: имя исходного файла и имя ссылки. Рассмотрим пример:
\lstinputlisting{../listings/link}

\subsubsection{cp}

Утилита \textbf{cp} создана для копирования файлов, а не создания ссылок. Однако, как уже было продемонстрировано в первом отчёте, создать символьные и жёсткие ссылки можно c помощью флагов -s и -l, соответственно. Рассмотрим пример:
\lstinputlisting{../listings/cp}

\subsection{Отображение}
В примерах выше, мы видели, что утилита \textbf{ls} указывает файл, на который указывает ссылка. Но путь к этому относителен по отношению к самой ссылке. Рассмотрим на примере утилиты \textbf{ls} и \textbf{cp}:
\lstinputlisting{../listings/symlinkpath}
Из примера видно, что утилита \textbf{ln} создаёт ссылку на файл относительно директории вызова утилиты. Поэтому, ссылка sym\_link1, помещённая на директорию ниже, указывала на файл, находящийся на директорию ниже. Эту особенность мы обошли с помощью флага -r, скорректировавшего путь относительно местоположения ссылки. А утилита \textbf{cp} не позволяет создавать символьные ссылки в директории, отличной от текущей.

До этого мы пользовались общей утилитой \textbf{ls} для просмотра ссылок, но есть и специализированные - \textbf{readlink} и \textbf{realpath}. Рассмотрим:
\lstinputlisting{../listings/readlink}
Из приведённого видно, что для ссылки можно получить и полный путь.
\section{Символьные ссылки} Предложить скрипт, подсчитывающий и перечисляющий все полноименные символьные ссылки на файл, размещаемые в разных местах файлового дерева. Получить все символьные ссылки на заданный в качестве входного параметра файл, не используя file.

\lstinputlisting{../listings/sym_search}

Первой командой данного скрипта мы узнаём и запоминаем полный путь до указанного нами файла. А первые шаги поиска ссылок нам уже известны: модификация вывода утилиты \textbf{ls}, добавляющая полный путь к файлам. После чего выделяются только ссылки и по полному пути к ним утилитой \textbf{realpath} идентифицируется файл, на который они ссылаются. Этот результат файл сравнивается с запомненным в начале скрипта по полному пути и имени.

Данный скрип не считает количество ссылок, а всего лишь выводит их. Но этот функционал легко добавить конвейером, что сейчас и рассмотрим.
\lstinputlisting{../listings/sym_search_examp}
Из приведённого видно, что утилита \textbf{wc} позволяет посчитать количество строк, что нам и требуется. Таким образом мы узнали, что у нас есть 3 символьных ссылки на этот файл.

\section{Find} \subsection{Задание:}Изучить утилиту , используя ее ключи получить расширенную информацию о всех типах файлов. Создать примеры вложенных команд.
\subsection{Расширенно о типах файлов}
Утилиты \textbf{find} имеет фалг -ls соответствующий форме вывода утилиты \textbf{ls} с флагами -dils, однако пользоваться рассматриваемой сейчас утилитой проще, так как она позволяет легко организовать вложенность. Найдём по одному примеру файла каждого типа:
\lstinputlisting{../listings/find}
\subsection{Вложенные команды}
Одна из важных особенностей утилиты - возможность вызывать утилиты внутри самой утилиты. Существует несколько типов вызова утилит:
\begin{itemize}
\item exec - вызывает утилиту из активной директории
\item execdir - вызывает утилиту из директории файла
\item ok - аналог exec, но подтверждения для каждого файла
\item okdir - аналог execdir, но подтверждения для каждого файла
\end{itemize}
Рассмотрим работу со вложенными командами:
\lstinputlisting{../listings/find_in}
И приведённого видна разница между exec и execdir по утилите \textbf{pwd}. И продемонстрирована возможность создавать и удалять файлы по различным критериям с использованием вложенных команд.
\section{Заголовок файла} \subsection{Задание:}Проанализировать содержимое заголовка файла, а также файла-каталога с помощью утилит od  и  *dump. 
Если доступ к файлу-каталогу возможен (для отдельных модификаций POSIX-совместимых ОС), проанализировать изменение его содержимого при различных операциях над элементами, входящими в его состав (файлами и подкаталогами).  
\subsection{Эксперименты:}
\lstinputlisting{../listings/od}
Из приведённого видно, как выглядят пустой файл и текстовый файл из двух символов. Нулевой заголовок и EOF для непустого текстового файла.

В определённый момент развития ОС Linux, вероятно при переходе от записей в файлах директорий фиксированной длинны к переменной, было решено отгородить пользователя от работы с менее тривиальной структурой. Так уже много лет директории недоступны для системного вызова read(), а имеют собственный readdir() и getdents(). И именно из-за использования read() утилиты cat, od и подобные не могут продемонстрировать нам дирректорию. Однако утилита dumpfs позволяет сделать дамп файла директории. Для эксперимента был отформатирован usb-накопитель в ФС ext4. Файл устройства /dev/sdd1.\\

\noindent Создадим пустую директорию в корне:
\lstinputlisting{../listings/dirdump_create_dir}
Теперь создадим дамп:
\lstinputlisting{../listings/dirdump_dump}
Теперь дамп находится в файле dir\_dump, рассмотрим уже его дамп:
\lstinputlisting{../listings/dirdump_dump_of_the_dump}
Первые 4 байта дампа соответствуют inode самой директории, следующие 4 байта пока не очевидны и ещё 4 байта содержат имя директории ".". Такой же набор в 12 байт для родительской директории имя - ".." и inode - 2, так как родителем является корень данной ФС. Оставшаяся область файла заполнена нулями.\\
Для уточнения средних 4 байт создадим файлы различных типов:
\lstinputlisting{../listings/dirdump_files}
Рассмотрим новый дамп:
\lstinputlisting{../listings/dirdump_dump_of_the_dump2}
Теперь ясно, что на один файл может выделяться больше 12 байт, в зависимости от длины имени. А ранее не очевидные значения второй четвёрки байт в записи имеют такие побайтные значения:
\begin{itemize}
\item Общая длина записи + 2 (младшая часть)
\item Старшая часть
\item Длина имени
\item Тип файла
\end{itemize}
Общая длина записи у сокета, вероятно имеет иное значение или формируется из других атрибутов. Немаловажно, что сокет был создан не родной утилитой и является самым сложным из приведённых типов файлов.

\section{Максимальное количество записей в каталоге}
\subsection{Задание:} Определить максимальное количество записей в каталоге. 
Изменить размер каталога, варьируя количество записей (для этого создать программу, порождающую новые файлы и каталоги, а затем удаляющую их, предусмотрев промежуточный и конечный вывод информации о размере подопытного каталога). 

\subsection{Эксперименты:}
Определение максимального количества файлов в каталоге для моей системы не имеет особого смысла, так как максимальное количество файлов в каталоге равно ограничено только максимальным количеством файлов в ФС для ext4. А максимальное количество файлов ограничено количеством inode'ов, которое варьируется, но потолком является $2^{32}-1$. Но существуют ещё популярные ФС с существенно ограниченным, но всё же большим, количеством файлов в директории, например, FAT32. Для неё это значение равно $2^{16}-1$. Рассмотрим простой скрипт для обнаружения этого ограничения:

\lstinputlisting{../listings/max_count}
Проверим работу на отформатированном в FAT32 USB-флеш накопителе:
\lstinputlisting{../listings/max_count_examp}
Из примера видно, что удалось создать 65533 файла. Это обоснованно тем, что в директории изначально находятся два файла: ссылка на себя и ссылка на родителя. Описание такого количество файлов в файле каталога занимает порядка 2 мегабайт.


Теперь рассмотрим первые 10 изменений размера файла каталога. Для этого модифицируем скрипт:
\lstinputlisting{../listings/increase_count.sh}
Рассмотрим поведение системы в рамках ФС FAT32:
\lstinputlisting{../listings/increase_count_examp}
В левом столбце вывода расположен размер директории, а в правом - номер файла, вызвавшего увеличение (в директории на 2 файла больше). В этой ФС увеличение файла каталога имеет константный инкремент.

Теперь рассмотрим поведение системы в рамках родной для неё ФС ext4:
\lstinputlisting{../listings/increase_count_examp2}
Этот случай отличается от предыдущего тем, что первое увеличение отличается от остальных, которые уже имеют константный инкремент, сходный с рассмотренным для FAT32. Но зависимость от количества файлов тут не линейна.
\section{Файлы описания пользователя} \subsection{Задание:} Ознакомиться с содержимым /etc/passwd, /etc/shadow, с утилитой /usr/bin/passwd, проанализировать права доступа к этим файлам.
\subsection{ Теория:}
Системе необходимо где-то хранить информацию о пользователях и основным местом для этого является файл /etc/passwd. Рассмотрим первые его строки:
\lstinputlisting{../listings/passwd}
Как видно из примера, в присутствует определённый формат данных, рассмотри его:

[Имя]:[Пароль]:[№ Пользователя]:[№ Группы]:[Домашняя Директория]:[Интерпретатор]

Однако из-за доступности файла хранить в нём пароли не желательно, поэтому в поле пароля мы наблюдаем "х". Для хранения паролей используется файл /etc/shadow. Он имеет специфичные права доступа в системах семейства RH:
\lstinputlisting{../listings/shadow_rights}
В ОС семейства Ubuntu права нагляднее:
\lstinputlisting{../listings/shadow_rights_u}
В обоих случаях прямую запись в файл может выполнить только владелец файла, root.

Рассмотрим первые строки:
\lstinputlisting{../listings/shadow}
Как видно из примера, в присутствует определённый формат данных, рассмотри его:
\begin{itemize}
\item Имя пользователя. Сопоставляется с оным в /ets/passwd
\item Зашифрованный пароль — от 13 до 24 символов. Пароль зашифрован с помощью библиотечной функции crypt(3) или по хеш алгоритму md5. В этом поле, значения отличные от корректно зашифрованного или хешированного пароля используются для контроля. Например, если значение равно ! or *, аккаунт заблокирован и пользователю вход не разрешён . Если же !! , то пароль не установлен
\item Время последнего изменения пароля (от 01.01.1970)
\item Число дней до возможности сменить пароль
\item Число дней до необходимости поменять пароль
\item Число дней за которое появится предупреждения о необходимости смены пароля
\item Число дней до деактивации аккаунта после окончания срока годности пароля
\item Число дней с момента деактивации пользователя
\item Зарезервированные поля — сейчас игнорируются в большинстве систем
\end{itemize}

\subsection{Эксперименты:}
Для этого опыта создадим пользователя lab2:
\lstinputlisting{../listings/passwd_examp}
Значения по умолчанию подразумевают, что перейти в пользователя lab2 можно, только будучи суперпользователем. Это обоснованно тем, что пароль не задан вовсе, а не задан пустой. Поэтому все попытки входа будут неудачны, кроме той, что не требует пароля вовсе.
\lstinputlisting{../listings/passwd_login}
Зададим пароль:
\lstinputlisting{../listings/passwd_set}
Из приведённого видно, что поменять пароль может только суперпользователь. И пароль работает.\\

Рассмотрим влияние файла /etc/passwd:
\lstinputlisting{../listings/passwd_change}
То есть отсутствие пароля здесь означает отсутствие пароля у пользователя. А наличие чего-либо отличного от ничего и "х" не позволяет проверить пароль в /etc/shadow и не является паролем.
\section{Права владения и доступа} Исследовать права владения и доступа, а также их сочетаемость
\subsection{ Привести} примеры применения утилит chmod, chown к специально созданному для этих целей отдельному каталогу с файлами. 
\subsection{ Расширить} права исполнения экспериментального файла с помощью флага SUID. 
\subsection{ Экспериментально} установить, как формируются итоговые права на использование файла, если права пользователя и группы, в которую он входит, различны.
\subsection{ Сопоставить} возможности исполнения наиболее часто используемых операций, варьируя правами доступа к файлу и каталогу.

\section{«Программа-шлюз» } Разработать «программу-шлюз» для доступа к файлу другого пользователя при отсутствии прав на чтение информации из этого файла. Провести эксперименты для случаев, когда пользователи принадлежат одной и разным группам. Сравнить результаты. Для выполнения задания применить подход, аналогичный для обеспечения функционирования утилиты /usr/bin/passwd (манипуляции с правами доступа, флагом SUID, а также размещением файлов).

\section{ df и аналоги} Применяя утилиту df и аналогичные ей по функциональности утилиты, а также информационные файлы типа fstab, mtab и т.п. получить информацию о файловых системах, возможных для монтирования, а также установленных на компьютере реально. 
\subsection{ Привести} информацию об исследованных утилитах и информационных файлах с анализом их содержимого и форматов. 
\subsection{ Привести} образ диска с точки зрения состава и размещения всех ФС на испытуемом компьютере, а также образ полного дерева ФС, включая присоединенные ФС съемных и несъемных носителей. Проанализировать и указать формат таблицы монтирования.
\subsection{ Привести} «максимально возможное» дерево ФС, проанализировать, где это указывается

\section{ File} Проанализировать и пояснить принцип работы утилиты file.  
\subsection{ Привести} алгоритм её функционирования на основе информационной базы, размещение и полное имя которой указывается в описании утилиты в технической документации ОС (как правило, /usr/share/file/magic.*), а также содержимого заголовка файла, к которому применяется утилита. Определить, где находятся магические числа и иные характеристики, идентифицирующие тип файла, применительно к исполняемым файлам, а также файлам других типов. 
\subsection{ Утилиту} file выполнить с разными ключами. 
\subsection{ Привести} экспериментальную попытку с добавлением в базу собственного типа файла и его дальнейшей идентификацией. Описать эксперимент и привести последовательность действий для расширения функциональности утилиты file и возможности встраивания дополнительного типа файла в ФС (согласовать содержимое информационной базы и заголовка файла нового типа).

\end{document}